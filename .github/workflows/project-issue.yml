# reusable workflow
# - each job listed separately in ui
# - can fetch job status via api
# - do not need a separate repository
# - do not need to keep node packages up to date

# future TODOs
# break up into multiple files, workflows, or actions
# add support for external configuration json

# TODO Add to verification link (release link, pull request link, etc.)

name: 'Check project issue'

on:
  workflow_call:

env:
  # labels used for different types of requests
  GRADE_TESTS:    'grade-tests' # label used to request tests grade
  GRADE_REVIEW:   'grade-review' # label used to request code review grade
  GRADE_RELEASE:  'grade-release' # label used to request final release grade
  REQUEST_REVIEW: 'review-request' # label used to request code review

  # deadlines for code reviews
  # for some reason these are getting converted into mm/dd/yyyy hh:mm:ss format
  PROJECT_1_REVIEW: "2022-03-08T23:59:59"
  PROJECT_2_REVIEW: "2022-04-05T23:59:59"
  PROJECT_3_REVIEW: "2022-04-26T23:59:59"

  # default messages
  # newlines require " " style double quotes
  RUN_DETAIL: "\n\n:octocat: @${{ github.actor }} see [run id ${{ github.run_id }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details."
  FIX_ERRORS: "After fixing this request, remove the `error` label and re-open this issue."

jobs:
  check_issue:
    name: 'Issue'
    runs-on: 'ubuntu-latest'

    outputs:
      type: '${{ steps.check_labels.outputs.type }}' # type of request parsed from labels
      name: '${{ steps.check_body.outputs.name }}'   # name of student parsed from body
      user: '${{ steps.check_body.outputs.user }}'   # username of student parsed from body

      release: '${{ steps.check_title.outputs.release }}' # release parsed from title
      project: '${{ steps.check_title.outputs.project }}' # number of project parsed from release
      reviews: '${{ steps.check_title.outputs.reviews }}' # number of reviews parsed from release

      mile: '${{ steps.check_miles.outputs.mile }}' # milestone to use based on project number

    steps:
      - name: 'Startup'
        uses: 'actions/github-script@v6'
        with:
          script: |
            github.rest.issues.createComment({owner: context.repo.owner, repo: context.repo.repo, issue_number: context.payload.issue.number, body: `:robot: The GitHub Actions bot is now processing your request...${ process.env.RUN_DETAIL}`});
            console.log(context);

      - name: 'Check issue labels'
        id: 'check_labels'
        if: ${{ always() }}
        uses: 'actions/github-script@v6'
        with:
          script: |
            const { GRADE_TESTS, GRADE_REVIEW, GRADE_RELEASE, REQUEST_REVIEW } = process.env;
            const labels = context.payload.issue.labels.map(e => e.name);
            console.log(`Labels: ${labels}`);

            if (labels.length == 1) {
              const label = labels[0];

              switch (label) {
                case REQUEST_REVIEW:
                case GRADE_TESTS:
                case GRADE_REVIEW:
                case GRADE_RELEASE:
                  core.setOutput('type', label);
                  return;
              }
            }

            // only errors will get this far
            core.setOutput('error_message', `:no_entry: Unable to determine request type from issue #${ context.payload.issue.number } labels: ${labels.length === 0 ? '*(none)*' : labels.join(', ')}\n\nMake sure to use the provided issue templates. ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
            core.setFailed(`Unable to determine request type from issue #${ context.payload.issue.number } labels: ${labels.length === 0 ? '(none)' : labels.join(', ')}`);

      - name: 'Check issue body'
        id: 'check_body'
        if: ${{ always() }}
        uses: 'actions/github-script@v6'
        with:
          script: |
            const body = context.payload.issue.body;
            let error_message = undefined;

            try {
              const pattern = /```json([^`]+)```/;
              const matched = body.match(pattern);

              const parsed = JSON.parse(matched[1]);
              console.log(`Parsed: ${JSON.stringify(parsed)}`);

              if(!parsed.hasOwnProperty('name') || !parsed.hasOwnProperty('username')) {
                error_message = `Both the "name" and "username" properties are required in the issue #${ context.payload.issue.number } body.`;
              }
              else if (parsed.name === "FULL_NAME" || parsed.username === "USF_USERNAME") {
                error_message = `The "name" and "username" properties in the issue #${ context.payload.issue.number } body must be updated.`;
              }
              else {
                core.setOutput('name', parsed.name.trim());
                core.setOutput('user', parsed.username.trim());
                return;
              }
            }
            catch (error) {
              error_message = `Unable to parse issue #${ context.payload.issue.number } body as JSON. Error: ${error.message}`;
            }

            // only errors will get this far
            core.setOutput('error_message', `:no_entry: ${error_message}\n\nMake sure to use the provided issue templates. ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
            core.setFailed(error_message);

      - name: 'Check issue title'
        id: 'check_title'
        if: ${{ always() }}
        uses: 'actions/github-script@v6'
        env:
          REQUEST_TYPE: '${{ steps.check_labels.outputs.type }}'
        with:
          script: |
            const title = context.payload.issue.title;
            console.log(`Issue Title: ${ title }`);

            const pattern = /^Request.+\b(v([1-4])\.(\d+)\.\d+)$/;
            const matched = title.match(pattern);

            if (matched !== null && matched.length === 4) {
              const release = matched[1];
              const project = parseInt(matched[2]);
              const reviews = parseInt(matched[3]);

              core.setOutput('release', release);
              core.setOutput('project', project);
              core.setOutput('reviews', reviews);

              console.log(`Release: ${release}, Project: ${project}, Reviews: ${reviews}`);

              if (reviews > 1 && process.env.REQUEST_TYPE == process.env.GRADE_REVIEW) {
                // only request code review grades for code review 0 and 1
                core.setOutput('error_message', `:no_entry: Invalid grade request; you can only request code review grades for your first two code reviews. ${ process.env.RUN_DETAIL }`);
                core.setFailed(`Invalid request; you can only request code review grades for your first two code reviews.`);
              }
            }
            else {
              core.setOutput('error_message', `:no_entry: Unable to parse release from issue #${ context.payload.issue.number } title:\n\n> ${title}\n\nMake sure to replace \`v0.0.0\` in the issue title with a properly-formated release number. ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
              core.setFailed(`Unable to parse release from issue #${ context.payload.issue.number } title: ${ title }`);
            }

      - name: 'Check milestones'
        id: 'check_miles'
        uses: 'actions/github-script@v6'
        env:
          PROJECT_NUM: '${{ steps.check_title.outputs.project }}'
        with:
          script: |
            const name = `Project ${ process.env.PROJECT_NUM }`;
            console.log(`Milestone: ${ name }`);

            const milestones = await github.rest.issues.listMilestones({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            console.log(milestones);

            if (milestones.status != 200) {
              core.setOutput('error_message', `:no_entry: Unable to list milestones. This may be related to an outage. Check [GitHub status](https://www.githubstatus.com/) before trying again. ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
              core.setFailed(`Unable to list milestones. Status: ${milestones.status}`);
              return;
            }

            let found = milestones.data.find(milestone => milestone.title == name);
            console.log(found);

            if (found == undefined) {
              const created = await github.rest.issues.createMilestone({ owner: context.repo.owner, repo: context.repo.repo, title: name });
              console.log(created);

              if (created.status != 201) {
                core.setOutput('error_message', `:no_entry: Unable to create ${ name } milestone. This may be related to an outage. Check [GitHub status](https://www.githubstatus.com/) before trying again. ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
                core.setFailed(`Unable to create ${ name } milestone. Status: ${ created.status }`);
                return;
              }

              found = created.data;
            }

            core.setOutput('mile', found.number);
            console.log(`Milestone ${ found.title } has number: ${ found.number }`);

      - name: 'Check failures'
        id: 'check_failures'
        if: ${{ failure() }}
        uses: 'actions/github-script@v6'
        with:
          script: |
            const steps = ${{ toJSON(steps) }};
            console.log(steps);

            for (const step in steps) {
              if (steps[step].outcome == "failure" && steps[step].outputs.hasOwnProperty('error_message')) {
                // output the error as an issue comment
                github.rest.issues.createComment({owner: context.repo.owner, repo: context.repo.repo, issue_number: context.payload.issue.number, body: steps[step].outputs.error_message});
              }
            }

            // close the issue, assign it to the user, and apply the 'error' label
            const labels = context.payload.issue.labels.map(e => e.name);
            labels.push('error');

            github.rest.issues.update({owner: context.repo.owner, repo: context.repo.repo, issue_number: context.payload.issue.number, state: 'closed', assignees: [context.actor], labels: labels});

  check_actions:
    name: 'Actions'
    runs-on: 'ubuntu-latest'
    needs: ['check_issue']
    # top-level environment variables not yet supported
    # https://github.community/t/use-env-variable-for-jobs-id-runs-on-and-jobs-id-services-image/17281/3
    # https://docs.github.com/en/actions/learn-github-actions/contexts#env-context
    if: ${{ needs.check_issue.outputs.type == 'grade-tests' || needs.check_issue.outputs.type == 'grade-release' || needs.check_issue.outputs.type == 'review-request' }}

    outputs:
      error_message:  '${{ steps.check_status.outputs.error_message }}'
      submitted_id:   '${{ steps.find_passing.outputs.submitted_id }}'
      submitted_date: '${{ steps.find_passing.outputs.submitted_date }}'
      submitted_link: '${{ steps.find_passing.outputs.submitted_link }}'

    steps:
      - name: 'Find action runs'
        uses: 'actions/github-script@v6'
        id: 'find_runs'
        env:
          RELEASE: '${{ needs.check_issue.outputs.release }}'
        with:
          script: |
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'project-release.yml',
              per_page: 100
            });

            core.startGroup('Found runs...');
            console.log(runs);
            core.endGroup();

            if (runs.status != 200) {
              const error_message = `Unable to fetch runs for "Check project release" action (status ${runs.status}).`;
              core.exportVariable('ERROR_MESSAGE', `:no_entry: ${error_message}\n\nThis may be related to an outage. Check [GitHub status](https://www.githubstatus.com/) before trying again. ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
              core.setFailed(error_message);
            }
            else {
              const release = process.env.RELEASE;
              console.log(`Release: ${release}, Total Runs: ${runs.data.total_count}`);

              const filtered = runs.data.workflow_runs.filter(run => run.status === 'completed' && run.head_branch === release);

              core.startGroup('Filtered runs...');
              console.log(filtered);
              core.endGroup();

              if (filtered.length < 1) {
                core.exportVariable('ERROR_MESSAGE', `:no_entry: Unable to find any completed workflow runs for release: ${release}\n\nMake sure to create a release and wait for its action run to complete. ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
                core.setFailed(`Unable to find any completed workflow runs for release: ${release}`);
              }
              else {
                console.log(`Found ${filtered.length} completed runs for release ${release}: ${filtered.map(run => run.head_branch).join(', ')}`);
                return filtered;
              }
            }

      - name: 'Find passing runs'
        uses: 'actions/github-script@v6'
        id: 'find_passing'
        env:
          RELEASE: '${{ needs.check_issue.outputs.release }}'
          TYPE: '${{ needs.check_issue.outputs.type }}'
        with:
          script: |
            const release = process.env.RELEASE;
            const type = process.env.TYPE;
            console.log(`Type: ${type}, Release: ${release}`);

            const runs = ${{ steps.find_runs.outputs.result }};

            // try to find a successful run
            const success = runs.find(run => run.conclusion === 'success');

            if (success != undefined) {
              console.log(`Found successful run:`);
              console.log(success);

              core.setOutput('submitted_id', success.id);
              core.setOutput('submitted_date', success.head_commit.timestamp);
              core.setOutput('submitted_link', `[Run ID ${success.id}](${context.payload.repository.html_url}/actions/runs/${success.id})`);
              console.log(`ID: ${success.id}, Submitted: ${success.head_commit.timestamp}`);
              return;
            }
            else if (type == '${{ env.GRADE_TESTS }}') {
              for (const run of runs) {
                const results = await github.rest.actions.listJobsForWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: run.id,
                  filter: 'latest',
                  per_page: 100
                });

                core.startGroup('Workflow results...');
                console.log(results);
                core.endGroup();

                if (results.status != 200) {
                  const error_message = `Unable to fetch jobs for action run ${run.id}.`;
                  core.exportVariable('ERROR_MESSAGE', `:no_entry: ${error_message}\n\nThis may be related to an outage. Check [GitHub status](https://www.githubstatus.com/) before trying again. ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
                  core.setFailed(error_message);
                }
                else {
                  const test_job = results.data.jobs.find(job => job.name == 'Check / JUnit Tests');
                  console.log(`Check / JUnit Tests:`);
                  console.log(test_job);

                  if (test_job.conclusion == 'success') {
                    core.setOutput('submitted_id', run.id);
                    core.setOutput('submitted_date', run.head_commit.timestamp);
                    core.setOutput('submitted_link', `[Run ID ${run.id}](${context.payload.repository.html_url}/actions/runs/${run.id})`);
                    console.log(`ID: ${run.id}, Submitted: ${run.head_commit.timestamp}`);
                    return;
                  }
                }
              }

              // only get here if no successful test run found
              core.exportVariable('ERROR_MESSAGE', `:no_entry: No runs found that passed all tests for release \`${release}\`.\n\nMake sure the release in the issue title is associated with a completed run that passes all of the tests (the other checks are *optional* for this grade). ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
              core.setFailed(`No runs found that passed all tests for release ${release}.`);
            }
            else {
              core.exportVariable('ERROR_MESSAGE', `:no_entry: No runs found that passed all tests and checks for release \`${release}\`.\n\n\n\nMake sure there is a **completed** and **successful** run that passes all of the required tests and checks. ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
              core.setFailed(`No runs found that passed all tests and checks for release ${release}.`);
            }

      - name: 'Check status'
        id: 'check_status'
        if: ${{ failure() }}
        uses: 'actions/github-script@v6'
        with:
          script: |
            console.log(process.env.ERROR_MESSAGE);
            core.setOutput('error_message', process.env.ERROR_MESSAGE);

  check_reviews:
    name: 'Reviews'
    runs-on: 'ubuntu-latest'
    if: ${{ needs.check_issue.outputs.type == 'grade-release' || needs.check_issue.outputs.type == 'grade-review' || needs.check_issue.outputs.type == 'review-request' }}
    needs: ['check_issue']

    outputs:
      error_message:  '${{ steps.check_status.outputs.error_message }}'

      this_pull: '${{ steps.get_dates.outputs.this_pull }}' # pull request, empty if requesting review or release grade
      this_type: '${{ steps.get_dates.outputs.this_type }}' # quick or code, empty if release grade
      this_link: '${{ steps.get_dates.outputs.this_link }}' # appointment link, empty if requesting grade
      this_date: '${{ steps.get_dates.outputs.this_date }}' # date submitted (if requesting grade) or earliest eligible (if requesting review)
      this_full: '${{ steps.get_dates.outputs.this_full }}' # in full text format instead of ISO

      late_date: '${{ steps.get_dates.outputs.late_date }}' # deadline in ISO format
      late_full: '${{ steps.get_dates.outputs.late_full }}' # in full text format instead of ISO

      last_pull: '${{ steps.get_dates.outputs.last_pull }}' # pull request, empty if no code reviews
      last_type: '${{ steps.get_dates.outputs.last_type }}' # quick or code, empty if no code reviews
      last_pass: '${{ steps.get_dates.outputs.last_pass }}' # whether passed, empty if no code reviews or did not pass
      last_date: '${{ steps.get_dates.outputs.last_date }}' # date approved, empty if no code review
      last_full: '${{ steps.get_dates.outputs.last_full }}' # in full text format instead of ISO

    env:
      NEXT_MIN: 5  # Minimum number of days before next review (see: eligibility)
      NEXT_MAX: 10 # Maximum number of days before next review (see: late penalty)

    steps:
      - name: 'Get issues'
        id: 'get_issues'
        uses: 'actions/github-script@v6'

        env:
          PROJECT_NUM: '${{ needs.check_issue.outputs.project }}'
          REVIEWS_NUM: '${{ needs.check_issue.outputs.reviews }}'
          MILE_NUM: '${{ needs.check_issue.outputs.mile }}'
          RELEASE: '${{ needs.check_issue.outputs.release }}'
          TYPE: '${{ needs.check_issue.outputs.type }}'

        with:
          script: |
            const project = parseInt(process.env.PROJECT_NUM);
            const reviews = parseInt(process.env.REVIEWS_NUM);
            const milestone = parseInt(process.env.MILE_NUM);

            // use issues (not actions) since instructor can override issue behavior
            // returns issues and pull requests together
            const unfiltered = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              labels: `project${ project }`,
              milestone: milestone,
              sort: 'created',
              direction: 'desc',
              per_page: 100
            });

            core.startGroup('Found issues...');
            console.log(unfiltered);
            core.endGroup();

            if (unfiltered.status != 200) {
              const error_message = `Unable to fetch closed issues for project ${ project } with the correct assignees, milestone, and labels.`;
              core.exportVariable('ERROR_MESSAGE', `:no_entry: ${error_message}\n\nThis may be related to an outage. Check [GitHub status](https://www.githubstatus.com/) before trying again. ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
              core.setFailed(error_message);
              return;
            }

            // filter out issues with errors
            const passing = unfiltered.data.filter(issue => !issue.labels.some(label => label.name == "error"));
            console.log(`Found ${ unfiltered.data.length } issues.`);
            console.log(`Removed ${ unfiltered.data.length - passing.length } issues with errors.`);

            let issues = [];
            let pulls = [];

            // split into issues versus pull requests
            for (const item of passing) {
              if (item.hasOwnProperty('pull_request')) {
                pulls.push(item);
              }
              else {
                issues.push(item);
              }
            }

            console.log(`Found ${ issues.length } issues and ${ pulls.length } pull requests.`);

            // if code review grade, find all pull requests
            if (process.env.TYPE == process.env.GRADE_REVIEW) {
              // make sure at least one pull request for this release
              const found = pulls.find(issue => issue.title.endsWith(`Review ${ process.env.RELEASE }`));

              if (found == undefined) {
                const error_message = `You must have a code review and approved pull request for project ${ project } before requesting a code review grade.`;
                core.exportVariable('ERROR_MESSAGE', `:no_entry: ${error_message} ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
                core.setFailed(error_message);
                return;
              }

              // only get here if found a pull request
              // will check in other steps if was approved
              console.log(`Found pull request #${ found.number }: ${ found.title }`);
            }

            // if requesting code review appointment
            if (process.env.TYPE == process.env.REQUEST_REVIEW) {
              if (reviews == 0) {
                const found = issues.find(issue => issue.title.startsWith(`Request Test Grade v${ project }`));

                if (found == undefined) {
                  const error_message = `You must successfully request a project ${ project } test grade before requesting a code review.`;
                  core.exportVariable('ERROR_MESSAGE', `:no_entry: ${error_message} ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
                  core.setFailed(error_message);
                  return;
                }

                // only get here if found an issue
                console.log(`Found issue #${ found.number }: ${ found.title }`);
              }
              else {
                const found = issues.filter(issue => issue.title.startsWith(`Request Review Grade v${ project }`));

                console.log(`Found ${ found.length } review grade issues.`);

                if (
                    (reviews == 1 && found.length < 1) ||
                    (reviews >= 2 && found.length < 2)
                ) {
                  const error_message = `You must successfully request a project ${ project } review grade before requesting another code review.`;
                  core.exportVariable('ERROR_MESSAGE', `:no_entry: ${error_message} ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
                  core.setFailed(error_message);
                  return;
                }
              }
            }

            if (process.env.TYPE == process.env.GRADE_RELEASE) {
              const grades = issues.filter(issue => issue.title.startsWith(`Request Review Grade v${ project }`));

              console.log(`Found ${ grades.length } review grade issues.`);

              if (grades.length < 2) {
                const error_message = `You must successfully request both project ${ project } review grades before requesting a final release grade.`;
                core.exportVariable('ERROR_MESSAGE', `:no_entry: ${error_message} ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
                core.setFailed(error_message);
                return;
              }
            }

            // only keep pull requests
            return pulls;

      - name: 'Get pull requests'
        id: 'get_pulls'
        uses: 'actions/github-script@v6'

        env:
          PROJECT_NUM: '${{ needs.check_issue.outputs.project }}'
          REVIEWS_NUM: '${{ needs.check_issue.outputs.reviews }}'
          MILE_NUM: '${{ needs.check_issue.outputs.mile }}'
          RELEASE: '${{ needs.check_issue.outputs.release }}'
          TYPE: '${{ needs.check_issue.outputs.type }}'

        with:
          script: |
            // get pull requests to process
            const pulls = ${{ steps.get_issues.outputs.result }};
            console.log(`Loaded ${ pulls.length } pull requests.`);

            const project = parseInt(process.env.PROJECT_NUM);
            const reviews = parseInt(process.env.REVIEWS_NUM);
            const milestone = parseInt(process.env.MILE_NUM);

            let approved = [];

            // fetch reviews and keep only approved pulls
            for (const pull of pulls) {
              const found = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pull.number,
                per_page: 100
              });

              core.startGroup(`Found reviews for pull ${ pull.number }...`);
              console.log(found);
              core.endGroup();

              if (found.status != 200) {
                const error_message = `Unable to fetch reviews for pull request ${ pull.number } to verify approval.`;
                core.exportVariable('ERROR_MESSAGE', `:no_entry: ${error_message}\n\nThis may be related to an outage. Check [GitHub status](https://www.githubstatus.com/) before trying again. ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
                core.setFailed(error_message);
                return;
              }

              const reviewed = found.data.filter(review => review.user.login == 'sjengle' && review.state == 'APPROVED');
              console.log(`Found ${ reviewed.length } instructor approvals for pull ${ pull.number }.`);

              if (reviewed.length > 0) {
                // set to most recent code review
                pull.review = reviewed[reviewed.length - 1];
                approved.push(pull);
                console.log(`Approved at: ${ pull.review.submitted_at }`);
              }
            }

            const { GRADE_TESTS, GRADE_REVIEW, GRADE_RELEASE, REQUEST_REVIEW } = process.env;

            if (process.env.TYPE == REQUEST_REVIEW) {
              const found = approved.find(pull => pull.labels.some(label => label.name == 'review-passed'));

              if (found != undefined) {
                const error_message = `You passed code review in pull request #${found.number} and do not need to request any more code reviews for project ${ project }. Did you mean to request a final release grade instead?`;
                core.exportVariable('ERROR_MESSAGE', `:no_entry: ${error_message} ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
                core.setFailed(error_message);
                return;
              }
            }

            if (process.env.TYPE == GRADE_RELEASE) {
              const found = approved.find(pull => pull.labels.some(label => label.name == 'review-passed'));

              if (found == undefined) {
                const error_message = `You must have a passing code review for project ${ project } before requesting a final release grade. Did you mean to request a code review instead?`;
                core.exportVariable('ERROR_MESSAGE', `:no_entry: ${error_message} ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
                core.setFailed(error_message);
                return;
              }
            }

            if (process.env.TYPE == GRADE_RELEASE) {
              const found = approved.find(pull => pull.labels.some(label => label.name == 'review-passed'));

              if (found == undefined) {
                const error_message = `You must have a passing code review for project ${ project } before requesting a final release grade. Did you mean to request a code review instead?`;
                core.exportVariable('ERROR_MESSAGE', `:no_entry: ${error_message} ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
                core.setFailed(error_message);
                return;
              }
            }

            if (process.env.TYPE == GRADE_REVIEW) {
              const found = approved.find(pull => pull.title.endsWith(`Review ${ process.env.RELEASE }`));

              if (found == undefined) {
                const error_message = `Could not find an approved pull request for release ${ process.env.RELEASE }. You must have a code review and approved pull request for project ${ project } before requesting a code review grade.`;
                core.exportVariable('ERROR_MESSAGE', `:no_entry: ${error_message} ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
                core.setFailed(error_message);
                return;
              }
            }

            console.log(`Found ${ approved.length } approved pull requests.`);
            return approved;

      - name: 'Setup node'
        uses: 'actions/setup-node@v2'
        with:
          node-version: '16'

      - name: 'Install luxon'
        run: npm install luxon

      - name: 'Get dates'
        id: 'get_dates'
        uses: 'actions/github-script@v6'

        env:
          PROJECT_NUM: '${{ needs.check_issue.outputs.project }}'
          REVIEWS_NUM: '${{ needs.check_issue.outputs.reviews }}'
          RELEASE: '${{ needs.check_issue.outputs.release }}'
          TYPE: '${{ needs.check_issue.outputs.type }}'

        with:
          script: |
            const { DateTime } = require('luxon');
            const zone = 'America/Los_Angeles';

            const project = parseInt(process.env.PROJECT_NUM);
            const reviews = parseInt(process.env.REVIEWS_NUM);

            const this_review = {
              'this_pull': '',  // pull request, empty if requesting review or release grade
              'this_type': '',  // quick or code, empty if release grade
              'this_link': '',  // appointment link, empty if requesting grade
              'this_date': '',  // date submitted (if requesting grade) or earliest eligible (if requesting review)
              'this_full': '',  // in full text format instead of ISO
              'late_date': '',  // deadline in ISO format
              'late_full': '',  // in full text format instead of ISO
            };

            const last_review = {
              'last_pull': '', // pull request, empty if no code reviews
              'last_type': '', // quick or code, empty if no code reviews
              'last_pass': '', // whether passed, empty if no code reviews or did not pass
              'last_date': '', // date approved, empty if no code review
              'last_full': '', // in full text format instead of ISO
            };

            const approved = ${{ steps.get_pulls.outputs.result }};
            core.startGroup(`Loaded ${ approved.length } pull requests.`);
            console.log(approved);
            core.endGroup();

            let current = undefined;
            let earlier = undefined;

            if (process.env.TYPE == process.env.REQUEST_REVIEW) {
              earlier = approved.find(pull => reviews > 0 && pull.title.includes(`Review v${ project }.${ reviews - 1 }.`));

              let start = DateTime.now().setZone(zone);
              let quick = false;

              if (earlier != undefined) {
                // start is 5 days since last code review
                start = DateTime.fromISO(earlier.review.submitted_at, { zone: zone }).plus({ days: process.env.NEXT_MIN });
                quick = earlier.labels.some(label => label.name == 'review-resubmit-quick');
              }

              this_review.this_date = start.toISO();
              this_review.this_full = start.toLocaleString(DateTime.DATE_HUGE);

              this_review.this_type = quick ? 'Quick' : 'Code';
              this_review.this_link = `https://calendly.com/sjengle/${ this_review.this_type.toLowerCase() }-review?month=${ start.toFormat('yyyy-MM') }&date=${ start.toFormat('yyyy-MM-dd') }`;
            }

            if (process.env.TYPE == process.env.GRADE_REVIEW) {
              if (reviews == 0) {
                // something is converting the dates to non-ISO format
                const deadline = process.env[`PROJECT_${ project }_REVIEW`];
                const converted = DateTime.fromFormat(deadline, "MM/dd/yyyy HH:mm:ss");
                console.log(`Deadline: ${ deadline }, Converted: ${ converted }`);

                this_review.late_date = converted.toISO();
                this_review.late_full = converted.toLocaleString(DateTime.DATE_HUGE);
              }
              else {
                // earlier is the pull request before this release (if exists)
                earlier = approved.find(pull => pull.title.includes(`Review v${ project }.${ reviews - 1 }.`));

                if (earlier == undefined) {
                  core.setFailed(`Expected to find at least one approved v${ project }.${ reviews - 1 }.x pull request.`);
                }
              }

              // current is the pull request associated with the release
              current = approved.find(pull => pull.title.endsWith(`Review ${ process.env.RELEASE }`));

              if (current == undefined) {
                const error_message = `Could not find an approved pull request for release ${ process.env.RELEASE }. You must have a code review and approved pull request for project ${ project } before requesting a code review grade.`;
                core.exportVariable('ERROR_MESSAGE', `:no_entry: ${error_message} ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
                core.setFailed(error_message);
                return;
              }
            }

            if (process.env.TYPE == process.env.GRADE_RELEASE) {
              // earlier is the pull request that passed code review
              earlier = approved.find(pull => pull.labels.some(label => label.name == 'review-passed'));

              if (earlier == undefined) {
                core.setFailed(`Expected to find at least one passing pull request.`);
              }

              const deadline = DateTime.fromISO(earlier.review.submitted_at, { zone: zone }).plus({ days: process.env.NEXT_MAX });
              this_review.late_date = deadline.toISO();
              this_review.late_full = deadline.toLocaleString(DateTime.DATE_HUGE);
            }

            core.startGroup('Found pull requests:');
            console.log('Current:', current);
            console.log('Earlier:', earlier);
            core.endGroup();

            if (current != undefined) {
              this_review.this_pull = current.number;
              this_review.this_type = current.title.startsWith('Quick') ? 'Quick' : 'Code';

              const submitted = DateTime.fromISO(current.review.submitted_at, { zone: zone });
              this_review.this_date = submitted.toISO();
              this_review.this_full = submitted.toLocaleString(DateTime.DATE_HUGE);
            }

            if (earlier != undefined) {
              last_review.last_pull = earlier.number;
              last_review.last_type = earlier.title.startsWith('Quick') ? 'Quick' : 'Code';
              last_review.last_pass = earlier.labels.some(label => label.name == 'review-passed');

              const submitted = DateTime.fromISO(earlier.review.submitted_at, { zone: zone });
              last_review.last_date = submitted.toISO();
              last_review.last_full = submitted.toLocaleString(DateTime.DATE_HUGE);

              const deadline = submitted.plus({ days: process.env.NEXT_MAX });
              this_review.late_date = deadline.toISO();
              this_review.late_full = deadline.toLocaleString(DateTime.DATE_HUGE);
            }

            // set calculated values

            for (const output in this_review) {
              core.setOutput(output, this_review[output]);
            }

            console.log(this_review);

            for (const output in last_review) {
              core.setOutput(output, last_review[output]);
            }

            console.log(last_review);

      - name: 'Check status'
        id: 'check_status'
        if: ${{ failure() }}
        uses: 'actions/github-script@v6'
        with:
          script: |
            console.log(process.env.ERROR_MESSAGE);
            core.setOutput('error_message', process.env.ERROR_MESSAGE);

  make_grade:
    name: 'Grade'
    runs-on: 'ubuntu-latest'
    if: ${{ !failure() && (needs.check_issue.outputs.type == 'grade-release' || needs.check_issue.outputs.type == 'grade-tests' || needs.check_issue.outputs.type == 'grade-review') }}
    needs: ['check_issue', 'check_actions', 'check_reviews']

    outputs:
      error_message: '${{ steps.check_status.outputs.error_message }}'

    steps:
      - name: 'Load configuration'
        id: 'load_config'
        uses: 'actions/github-script@v6'
        with:
          script: |
              // get environment variables
              const { GRADE_TESTS, GRADE_REVIEW, GRADE_RELEASE} = process.env;

              // holds configuration constants
              const config = {
                deadline: {},
                possible: {},
                deduction: {},
                duration: {},
                maximum: {},
                assignment: {}
              };

              // when project tests are due
              config.deadline[GRADE_TESTS] = {
                project1: '2022-03-01T23:59:59',
                project2: '2022-03-29T23:59:59',
                project3: '2022-04-19T23:59:59',
                project4: '2022-05-10T23:59:59'
              };

              // when first code reviews are due
              config.deadline[GRADE_REVIEW] = {
                project1: process.env.PROJECT_1_REVIEW,
                project2: process.env.PROJECT_2_REVIEW,
                project3: process.env.PROJECT_3_REVIEW
              };

              // possible points total
              config.possible[GRADE_TESTS] =  100;
              config.possible[GRADE_REVIEW] =  25;
              config.possible[GRADE_RELEASE] = 50;

              // late deduction per x days
              config.deduction[GRADE_TESTS]   = 2;
              config.deduction[GRADE_REVIEW]  = 5;
              config.deduction[GRADE_RELEASE] = 5;

              // x days per late penalty (multiplier)
              config.duration[GRADE_TESTS]   = 1;
              config.duration[GRADE_REVIEW]  = 3;
              config.duration[GRADE_RELEASE] = 10;

              // maximum late penalty
              config.maximum[GRADE_TESTS]   = 26;
              config.maximum[GRADE_REVIEW]  = 20;
              config.maximum[GRADE_RELEASE] = 5;

              // assignment names
              config.assignment[GRADE_TESTS]   = 'Tests';
              config.assignment[GRADE_REVIEW]  = 'Code Review';
              config.assignment[GRADE_RELEASE] = 'Final Release';

              console.log(config);
              return config;

      - name: 'Lookup deadline'
        id: 'find_deadline'
        uses: 'actions/github-script@v6'

        env:
          PROJECT_NUM: '${{ needs.check_issue.outputs.project }}'
          REVIEWS_NUM: '${{ needs.check_issue.outputs.reviews }}'
          MILE_NUM: '${{ needs.check_issue.outputs.mile }}'
          RELEASE: '${{ needs.check_issue.outputs.release }}'
          TYPE: '${{ needs.check_issue.outputs.type }}'

        with:
          script: |
              const { GRADE_TESTS, GRADE_REVIEW, GRADE_RELEASE} = process.env;
              const config = ${{ steps.load_config.outputs.result }};

              // set grading parameters from past steps
              const results = {
                type:    process.env.TYPE,
                release: process.env.RELEASE,
                project: parseInt(process.env.PROJECT_NUM),
                reviews: parseInt(process.env.REVIEWS_NUM)
              };

              // set parameters based on grade type
              results.possible   = parseInt(config.possible[results.type]);
              results.deduction  = parseInt(config.deduction[results.type]);
              results.duration   = parseInt(config.duration[results.type]);
              results.maximum    = parseInt(config.maximum[results.type]);
              results.assignment = `Project ${ results.project } ${ config.assignment[results.type] }`;

              // set submitted
              switch (results.type) {
                // for tests and final release, based on release
                case GRADE_TESTS:
                case GRADE_RELEASE:
                  results.submitted_id   = '${{ needs.check_actions.outputs.submitted_id }}';
                  results.submitted_date = '${{ needs.check_actions.outputs.submitted_date }}';
                  results.submitted_link = '${{ needs.check_actions.outputs.submitted_link }}';
                  break;

                // for code review, based on pull request approval
                case GRADE_REVIEW:
                  results.assignment = `${ results.assignment } ${ results.reviews + 1 }`;

                  results.submitted_id   = '${{ needs.check_reviews.outputs.this_pull }}';
                  results.submitted_date = '${{ needs.check_reviews.outputs.this_date }}';
                  results.submitted_link = `${ context.payload.repository.html_url }/pull/${ results.submitted_id }`;
                  break;

                default:
                  core.setFailed(`Unexpected type: ${ config.type }`);
              }

              // set deadline
              switch (results.type) {
                // based on test deadline
                case GRADE_TESTS:
                  results.deadline = config.deadline[GRADE_TESTS][`project${ results.project }`];
                  break;

                // based on review deadline -or- last code review
                case GRADE_REVIEW:
                case GRADE_RELEASE:
                  // not used for project 4
                  if (parseInt(results.project) > 3) {
                    core.exportVariable('ERROR_MESSAGE', `:no_entry: This grade request is not supported for project ${ results.project }. ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
                    core.setFailed(`This grade request is not supported for project ${ results.project }.`);
                  }

                  results.deadline = config.deadline[GRADE_REVIEW][`project${ results.project }`];

                  if (results.reviews > 0) {
                    results.deadline = '${{ needs.check_reviews.outputs.late_date }}';
                  }

                  break;

                default:
                  core.setFailed(`Unexpected type: ${ results.type }`);
              }

              console.log(results);
              return results;

      - name: 'Setup node'
        uses: 'actions/setup-node@v2'
        with:
          node-version: '16'

      - name: 'Install luxon'
        run: npm install luxon

      - name: 'Calculate grade'
        id: 'calc_grade'
        uses: 'actions/github-script@v6'
        with:
          script: |
            const { DateTime } = require('luxon');
            const zone = 'America/Los_Angeles';

            const results = ${{ steps.find_deadline.outputs.result }};
            console.log(results);

            // convert date strings to date objects
            results.submitted_date = DateTime.fromISO(results.submitted_date, { zone: zone });
            let deadline = DateTime.fromISO(results.deadline, { zone: zone });

            if (!deadline.isValid) {
              // somewhere dates in environment variables are getting converted to a different form
              deadline = DateTime.fromFormat(results.deadline, "MM/dd/yyyy HH:mm:ss");
            }

            // TODO TESTING
            deadline = DateTime.now().minus({ days: 4 });

            results.deadline = deadline;

            // save text representations
            results.submitted_text = results.submitted_date.toLocaleString(DateTime.DATETIME_FULL);
            results.deadline_text = results.deadline.toLocaleString(DateTime.DATETIME_FULL);

            console.log(`Submitted: ${ results.submitted_text }, Deadline: ${ results.deadline_text }`);

            results.earned = parseInt(results.possible);
            results.late_days = 0;
            results.late_deduction = 0;

            if (results.submitted_date <= results.deadline) {
              core.notice(`The ${ results.assignment } assignment was submitted on ${ results.submitted_text }, before the ${ results.deadline_text } deadline.`);
            }
            else {
              const late_diff = results.submitted_date.diff(results.deadline, 'days');
              results.late_days = Math.ceil(late_diff.toObject().days);
              console.log(`The ${ results.assignment } assignment was submitted on ${ results.submitted_text }, which is ${ results.late_days } late.`);

              const late_mult = Math.ceil(results.late_days / results.duration);
              const late_loss = late_mult * results.deduction
              results.late_deduction = Math.min(late_loss, results.maximum);
              console.log(`The calculated late penalty is ${ late_loss }, or ${ results.late_deduction } after considering a maximum ${ results.maximum } penalty.`);

              results.earned = results.earned - results.late_deduction;
            }

            console.log(results);
            return results;

      - name: 'Check success'
        id: 'check_success'
        if: ${{ success() }}
        uses: 'actions/github-script@v6'
        with:
          script: |
            const results = ${{ steps.calc_grade.outputs.result }};

            const body = `
            :robot: @${{ github.actor }} your grade request has been processed! See the details below.

            |  |  |
            |----:|:-----|
            | Student: | ${{ needs.check_issue.outputs.name }} |
            | Username: | \`${{ needs.check_issue.outputs.user }}\` |
            | | |
            | Assignment: | \`${ results.assignment }\` |
            | Deadline: | ${ results.deadline_text } |
            | Submitted: | ${ results.submitted_text } |
            | Verification: | ${ results.submitted_link } |
            | | |
            | Late Days: | ${ results.late_days } days |
            | Late Penalty: | ${ results.late_deduction } points |
            | | |
            | Possible Grade: | ${ results.possible } points |
            | Earned Grade: | **${ results.earned } points** |

            You will receive a notice once your grade has been updated on Canvas.
            `;
            console.log(body);

            github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: context.payload.issue.number, body: body });

            const assignees = ['igentle292', 'mtquach2', 'par5ul1', 'tydaljames', 'ybsolomon'];
            const labels = [results.type, `project${ results.project }`];

            github.rest.issues.update({ owner: context.repo.owner, repo: context.repo.repo, issue_number: context.payload.issue.number, state: 'open', assignees: assignees, labels: labels, milestone: ${{ needs.check_issue.outputs.mile }} });

      - name: 'Check failure'
        id: 'check_failure'
        if: ${{ failure() }}
        uses: 'actions/github-script@v6'
        with:
          script: |
            console.log(process.env.ERROR_MESSAGE);
            core.setOutput('error_message', process.env.ERROR_MESSAGE);

  make_branch:
    name: 'Branch'
    if: ${{ !failure() && needs.check_issue.outputs.type == 'review-request' }}
    needs: ['check_issue', 'check_actions', 'check_reviews']
    runs-on: ubuntu-latest

    outputs:
      error_message: '${{ steps.check_status.outputs.error_message }}'

    steps:
      - name: 'Checkout repository'
        run: |
          git clone --depth 1 --no-tags https://github-actions:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }} project-main

      - name: 'Listing source code'
        working-directory: 'project-main'
        run: |
          ls -ACGR src/main/java

      - name: 'Fetching commit history and tags'
        working-directory: 'project-main'
        run: |
          git fetch --unshallow --tags

      - name: 'Comparing release to main branch'
        working-directory: 'project-main'
        run: |
          RUN_STATUS=0
          git diff --exit-code --shortstat origin/main refs/tags/${{ needs.check_issue.outputs.release }} || RUN_STATUS=$?

          if [[ RUN_STATUS -ne 0 ]]; then
            ERROR_MESSAGE="The main branch has one or more commits since release ${{ needs.check_issue.outputs.release }} was created. There must be no changes between the main branch and the release for code review."
            echo "ERROR_MESSAGE<<EOF" >> $GITHUB_ENV
            echo ":no_entry: ${ERROR_MESSAGE} ${FIX_ERRORS}" >> $GITHUB_ENV
            echo "${RUN_DETAIL}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            echo "::error ::${ERROR_MESSAGE}"
            exit 1
          fi

      - name: 'Creating review branch'
        working-directory: 'project-main'
        run: |
          RUN_STATUS=0
          git checkout -b review/${{ needs.check_issue.outputs.release }} || RUN_STATUS=$?

          if [[ RUN_STATUS -ne 0 ]]; then
            ERROR_MESSAGE="Unable to create review branch for release ${{ needs.check_issue.outputs.release }}. If this branch already exists, please delete it before requesting code review or request code review of a different release."
            echo "ERROR_MESSAGE<<EOF" >> $GITHUB_ENV
            echo ":no_entry: ${ERROR_MESSAGE} ${FIX_ERRORS}" >> $GITHUB_ENV
            echo "${RUN_DETAIL}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            echo "::error ::${ERROR_MESSAGE}"
            exit 1
          fi

      - name: 'Pushing review branch'
        working-directory: 'project-main'
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com

          git commit --allow-empty -m "Creating ${{ needs.check_issue.outputs.release }} review branch"

          RUN_STATUS=0
          git push -u origin review/${{ needs.check_issue.outputs.release }} || RUN_STATUS=$?

          if [[ RUN_STATUS -ne 0 ]]; then
            ERROR_MESSAGE="Unable to push review branch for release ${{ needs.check_issue.outputs.release }}. If this branch already exists, please delete it before requesting code review or request code review of a different release."
            echo "ERROR_MESSAGE<<EOF" >> $GITHUB_ENV
            echo ":no_entry: ${ERROR_MESSAGE} ${FIX_ERRORS}" >> $GITHUB_ENV
            echo "${RUN_DETAIL}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            echo "::error ::${ERROR_MESSAGE}"
            exit 1
          fi

      - name: 'Create pull request'
        id: 'create_pull'
        uses: 'actions/github-script@v6'
        with:
          script: |
            const last_type = '${{ needs.check_reviews.outputs.last_type }}';
            const last_pull = '${{ needs.check_reviews.outputs.last_pull }}';
            const last_date = '${{ needs.check_reviews.outputs.last_full }}';
            const last_pass = '${{ needs.check_reviews.outputs.last_pass }}';

            const this_type = '${{ needs.check_reviews.outputs.this_type }}';
            const this_date = '${{ needs.check_reviews.outputs.this_full }}';

            const late_date = '${{ needs.check_reviews.outputs.late_full }}';

            const last_link = last_pull ? `See pull request #${ last_pull } for the previous code review. ` : '';

            const body = `:robot: The code review request for [release \`${{ needs.check_issue.outputs.release }}\`](https://github.com/${{ github.repository }}/releases/tag/${{ needs.check_issue.outputs.release }}) has been processed:

            \`\`\`json
            {
              "name": "${{ needs.check_issue.outputs.name }}",
              "username": "${{ needs.check_issue.outputs.user }}",

              "release": "${{ needs.check_issue.outputs.release }}",
              "project": ${{ needs.check_issue.outputs.project }},
              "reviews": ${{ needs.check_issue.outputs.reviews }},

              "last_review": {
                "pull": "${ last_pull ? last_pull : 'N/A' }",
                "type": "${ last_type ? last_type.toLowerCase() : 'N/A' }",
                "date": "${ last_date ? last_date : 'N/A' }",
                "pass": ${ last_pass ? true : false }
              },

              "this_review": {
                "type": "${ this_type ? this_type.toLowerCase() : 'N/A' }",
                "date": "${ this_date ? this_date : 'N/A' }",
                "late": "${ late_date ? late_date : 'N/A' }"
              }
            }
            \`\`\`

            ${ last_link }This pull request closes #${ context.payload.issue.number } -- see [run id ${{ github.run_id }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for run details.
            `;

            console.log(body);

            const result = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '${{ needs.check_reviews.outputs.this_type }} Review ${{ needs.check_issue.outputs.release }}',
              head: 'review/${{ needs.check_issue.outputs.release }}',
              base: 'main',
              body: body
            });

            console.log(result);

            if (result.status != 201) {
              const error_message = `Unable to create pull request for release ${{ needs.check_issue.outputs.release }} (status ${result.status}).`;
              core.exportVariable('ERROR_MESSAGE', `:no_entry: ${ error_message }\n\nThis may be related to an outage. Check [GitHub status](https://www.githubstatus.com/) before trying again. ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`);
              core.setFailed(error_message);
            }

            return result.data;

      - name: 'Update pull request'
        uses: 'actions/github-script@v6'

        env:
          REVIEW_TYPE: '${{ needs.check_reviews.outputs.this_type }}'
          REVIEW_DATE: '${{ needs.check_reviews.outputs.this_full }}'
          REVIEW_LATE: '${{ needs.check_reviews.outputs.late_full }}'
          REVIEW_LINK: '${{ needs.check_reviews.outputs.this_link }}'

        with:
          script: |
            // only used if something here fails
            core.exportVariable('ERROR_MESSAGE', `:no_entry: Something went wrong updating the pull request. Reach out to the instructor on Piazza for next steps. ${ process.env.RUN_DETAIL }`);

            // get pull request results
            const results = ${{ steps.create_pull.outputs.result }};

            // craft link
            const link = `${ process.env.REVIEW_LINK }&name=${ encodeURIComponent('${{ needs.check_issue.outputs.name }}') }&email=${encodeURIComponent('${{ needs.check_issue.outputs.user }}')}@dons.usfca.edu&a1=${ encodeURIComponent(results.html_url) }`;
            console.log(link);

            const body = `:robot: Congratulations @${{ github.actor }}, your code review request has been approved. See below for how to proceed.

            ## :memo: Instructions

            Use [**this personalized appointment signup link**](${ link }) to sign up for a code review.

            The earliest you are eligible to have a code review is **${ process.env.REVIEW_DATE }**. You must have a code review by **${ process.env.REVIEW_LATE }** to avoid late penalties. You may only have one upcoming appointment at a time!

            ## :warning: Warnings

            Be careful to avoid the following issues before your appointment:

              - **Do not make modifications to the code in your \`main\` branch before your appointment.** If your code is not ready for code review, close this request, cancel your appointment, and re-request a code review when your code is ready.

              - **Do not merge this pull request until it is approved by the instructor during your code review appointment.** If you accidentally merge this pull request before your appointment, you will have to close this review request, cancel your appointment, and re-request a code review.

              - **Do not abuse the appointment system.** This includes signing up for more than one appointment at a time, signing up before you are eligible for an appointment, arriving more than 5 minutes late or missing an appointment, and signing up for an appointment before you are approved.

            Repeat issues with the code review process may result in a point deduction to your code review grades.
            `;

            console.log(body);

            // add instructions
            const pull_comment = github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: results.number,
              body: body
            });

            // request code review
            const request_review = github.rest.pulls.requestReviewers({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: results.number,
              reviewers: ['sjengle']
            });

            // update pull request labels and milestone
            const update_pull = github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: results.number,
              assignees: ['${{ github.actor }}'],
              labels: ['project${{ needs.check_issue.outputs.project }}'],
              milestone: ${{ needs.check_issue.outputs.mile }}
            });

            // update request issue
            const issue_comment = github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: `:robot: @${{ github.actor }} your code review request has been processed! See pull request #${results.number} for additional instructions.
              `
            });

            // close request issue
            const issue_update = github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              assignees: ['${{ github.actor }}'],
              labels: ['${{ needs.check_issue.outputs.type }}', 'project${{ needs.check_issue.outputs.project }}'],
              milestone: ${{ needs.check_issue.outputs.mile }},
              state: 'closed'
            });

            // output results
            Promise.allSettled([pull_comment, request_review, update_pull, issue_comment, issue_update]).then(values => console.log(values));

      - name: 'Check failure'
        id: 'check_status'
        if: ${{ failure() }}
        uses: 'actions/github-script@v6'
        with:
          script: |
            console.log(process.env.ERROR_MESSAGE);
            core.setOutput('error_message', process.env.ERROR_MESSAGE);

  check_status:
    name: 'Status'
    if: ${{ failure() }}
    needs: ['check_actions', 'check_reviews', 'make_grade', 'make_branch']
    runs-on: 'ubuntu-latest'
    steps:
      - name: 'Check status'
        uses: 'actions/github-script@v6'
        with:
          script: |
            const results = ${{ toJSON(needs) }};
            console.log(results);

            for (const id in results) {
              if (results[id].result == "failure") {
                let message = results[id].outputs.error_message;

                if (!message) {
                  message = `:no_entry: The job \`${id}\` failed to complete successfully. ${ process.env.FIX_ERRORS } ${ process.env.RUN_DETAIL }`;
                }

                github.rest.issues.createComment({owner: context.repo.owner, repo: context.repo.repo, issue_number: context.payload.issue.number, body: message});
              }
            }

            // close the issue, assign it to the user, and apply the 'error' label
            const labels = context.payload.issue.labels.map(e => e.name);
            labels.push('error');

            github.rest.issues.update({owner: context.repo.owner, repo: context.repo.repo, issue_number: context.payload.issue.number, state: 'closed', assignees: [context.actor], labels: labels});
